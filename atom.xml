<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>松鼠的小站</title>
  
  <subtitle>优质坚果提供地</subtitle>
  <link href="http://sosupro.github.io/atom.xml" rel="self"/>
  
  <link href="http://sosupro.github.io/"/>
  <updated>2021-04-22T16:50:13.240Z</updated>
  <id>http://sosupro.github.io/</id>
  
  <author>
    <name>sosusosu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Educational Codeforces Round 107</title>
    <link href="http://sosupro.github.io/2021/04/23/Educational-Codeforces-Round-107-Rated-for-Div-2-cf-contest-1511/"/>
    <id>http://sosupro.github.io/2021/04/23/Educational-Codeforces-Round-107-Rated-for-Div-2-cf-contest-1511/</id>
    <published>2021-04-22T16:44:22.000Z</published>
    <updated>2021-04-22T16:50:13.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Educational-Codeforces-Round-107-Rated-for-Div-2-https-codeforces-com-contest-1511"><a href="#Educational-Codeforces-Round-107-Rated-for-Div-2-https-codeforces-com-contest-1511" class="headerlink" title="Educational Codeforces Round 107 (Rated for Div. 2)(https://codeforces.com/contest/1511)"></a>Educational Codeforces Round 107 (Rated for Div. 2)(<a href="https://codeforces.com/contest/1511">https://codeforces.com/contest/1511</a>)</h1><h2 id="A-Review-Site"><a href="#A-Review-Site" class="headerlink" title="A Review Site"></a>A <a href="https://codeforces.com/contest/1511/problem/A">Review Site</a></h2><p>题目大意：A就不写题意了。</p><p>解法：分票，down全给一台，剩下的全给一台，所以答案就是n-down的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, a[<span class="number">55</span>], n1, n2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n, n1 = n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i]; </span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="number">1</span>) n1++;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="number">2</span>) n2++;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="number">3</span>) n1++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-GCD-Length"><a href="#B-GCD-Length" class="headerlink" title="B GCD Length"></a>B <a href="https://codeforces.com/contest/1511/problem/B">GCD Length</a></h2><p>题目大意：B还挺好玩，构造两个数，第一个数a位，第二个数b位，他们的gcd是c位。</p><p>解法：有很多种构造方法，我用的是三个数2,3,5；用2的次幂来构造gcd，用gcd×3的次幂构造第一个数，gcd×5的次幂来构造第二个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) ret += <span class="number">1</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="comment">//2, 3, 5</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">5</span>, n, m;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cal</span>(base) &lt; c) base *= <span class="number">5</span>;</span><br><span class="line">        n = m = base;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cal</span>(n) &lt; a) n *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cal</span>(m) &lt; b) m *= <span class="number">3</span>;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Yet-Another-Card-Deck"><a href="#C-Yet-Another-Card-Deck" class="headerlink" title="C Yet Another Card Deck"></a>C <a href="https://codeforces.com/contest/1511/problem/C">Yet Another Card Deck</a></h2><p>题目大意：有一堆牌，牌的种类最多50种，每次操作抽出某种牌最靠近牌堆顶的一张，输出这张是从顶往下数第几张，然后把这张牌放在牌堆顶。</p><p>解法：由于种类很少，所以直接模拟就ok，只要处理某一个种类的牌第一次抽是第几张就好了，剩下的情况因为种类过少所以一定存在某一种类会抽很多次，当某一种类被抽过一次之后他就一直在顶上那个范围了，所以硬爆其实也没多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, x, num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">300005</span>], color[<span class="number">105</span>], st[<span class="number">105</span>], v[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++) color[i] = <span class="number">1e9</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; a[i], color[a[i]] = <span class="built_in">min</span>(color[a[i]], i), st[a[i]] = color[a[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(!v[x])&#123;</span><br><span class="line">            num = <span class="number">0</span>, v[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) <span class="keyword">if</span>(v[j] &amp;&amp; st[j] &gt; st[x]) num++;</span><br><span class="line">            color[x] += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) <span class="keyword">if</span>(j != x &amp;&amp; v[j] &amp;&amp; color[j] &lt; color[x]) color[j]++;</span><br><span class="line">        cout &lt;&lt; color[x] &lt;&lt; <span class="string">&#x27; &#x27;</span>, color[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Min-Cost-String"><a href="#D-Min-Cost-String" class="headerlink" title="D Min Cost String"></a>D <a href="https://codeforces.com/contest/1511/problem/D">Min Cost String</a></h2><p>题目大意：D题需要构造一个代价最小的序列，一个序列的代价是满足如下条件：(si=sj且si+1=sj+1且i!=j)的(i,j)点对数。</p><p>解法：由于题意要求，有影响的只跟相邻两字母组成的二元组出现次数有关，手玩一下字符集比较小的情况，发现这样的二元组共有n×n种，而且这n×n个二元组可以不产生代价的出现在同一个序列中，比如字符集为3的情况，可以构造aabacbbc，这样是最优的情况，而最优序列显然是这样的一个序列重复出现。得到这样的猜测之后直接写个暴力dfs搜一下，发现所有的字符集都可以这样搜出来，那么我们这个做法就没有任何问题了。直接搜一个最优串，让这个串不停地重复出现就得到了答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, num[<span class="number">30</span>], a[<span class="number">200005</span>], w[<span class="number">200005</span>], mx, fl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fl) <span class="keyword">return</span>;</span><br><span class="line">    w[y] = x;</span><br><span class="line">    <span class="keyword">if</span>(y == k * k)&#123;</span><br><span class="line">        fl = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="keyword">if</span>(!vis[x][i] &amp;&amp; !fl)</span><br><span class="line">        vis[x][i] = <span class="number">1</span>, <span class="built_in">dfs</span>(i, y + <span class="number">1</span>), vis[x][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + w[i % (k * k)]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Colorings-and-Dominoes"><a href="#E-Colorings-and-Dominoes" class="headerlink" title="E Colorings and Dominoes"></a>E <a href="https://codeforces.com/contest/1511/problem/E">Colorings and Dominoes</a></h2><p>题目大意：一张图n行m列，有w个白色格子和n*m-w个黑色格子，黑色格子无法操作，白色格子可以涂成蓝色或者红色，然后如果有两个蓝色的格子竖着放在一起，那么他们两个上就可以放一个2×1的钻石，如果两个红色的格子横着放在一起，他们两个上边就可以放一个1×2的钻石，最后问所有的红蓝染色方案中，每个方案都按最大的放钻石方案放钻石，能放的钻石和是多少(任意方案都是最优的放置数量，要求的是所有方案的放置数量之和)。</p><p>解法：观察题面，可以将问题从 每个方案的数量和 转化为 求每个钻石所存在的方案数，然后找到所有能放的钻石，把每个钻石的方案数加起来。有了这个之后下来就解决最优放置的问题，实际上只要对于一排(或者一列)连续的白色格子，我们在这一排(或者一列)通过染色放置的钻石是最优的情况，那么剩下的点染什么色放什么钻石是剩下的点要考虑的事情，而每一种染色方案都一定可以得到一个对于那个方案的最优解，那样的解是无法影响我当前这连续的一排(或一列)格子的放置方案，所以这个题目就又被拆分成如下情况：当前有一排(或一列)连续的白色格子共k个，那么这k个格子对答案产生的贡献就是cal(k)*(2^(w-k))，我们只要分行和列分别讨论就可以得到结果。</p><p>接下来来解决这个cal(k)，这个东西咋整呢？因为k值和cal(k)是一一对应的，就可以把他当成一个数列，目测他是一个很有规律的东西，可以直接爆它的前几项，然后去OEIS一下，我们就得到这样一个数列：<a href="http://oeis.org/A045883">a(n) = ((3*n+1)*2^n - (-1)^n)/9</a>，然后就可以做啦！</p><p>不过OEIS实际上还是有点偏移我们之前分析出来的情况，如果从头开始重新考虑，对于连续的k个白色方块，我们可以放置钻石的位置实际上只有k-1个，而我在最后k的位置上放置钻石的方案数实际上是只跟1<del>k-2这些格子合法放置有关的，而之前在放置1</del>k-2这么多个格子的钻石的时候，我们是算过一部分和当前这两个格子有关的方案数的，于是dp[k]=dp[k-2]+(2^(w-k))就是现在的贡献，之后因为每个钻石都是占两个格子的，所以需要分奇偶讨论一下，这里就不做过多赘述了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a(n) = ((3*n+1)*2^n - (-1)^n)/9.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">300005</span>], ans, inv9, num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">string s[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret *= x, ret %= mo;</span><br><span class="line">        x *= x, x %= mo, y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inv9 = <span class="built_in">qpow</span>(<span class="number">9</span>, mo - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">300000</span>; i++)&#123;</span><br><span class="line">        a[i] = (((<span class="number">3</span> * i + <span class="number">1</span>) * <span class="built_in">qpow</span>(<span class="number">2LL</span>, i) % mo - <span class="built_in">qpow</span>(<span class="number">-1LL</span>, i) + mo) % mo * inv9 % mo);</span><br><span class="line">        a[i] = (a[i] + mo) % mo;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) num += s[i][j] == <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;o&#x27;</span>) pro++;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;*&#x27;</span> || j == m - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pro)&#123;</span><br><span class="line">                    ans += a[pro - <span class="number">1</span>] * <span class="built_in">qpow</span>(<span class="number">2</span>, num - pro) % mo, ans %= mo;</span><br><span class="line">                &#125;</span><br><span class="line">                pro = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;o&#x27;</span>) pro++;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;*&#x27;</span> || i == n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pro)&#123;</span><br><span class="line">                    ans += a[pro - <span class="number">1</span>] * <span class="built_in">qpow</span>(<span class="number">2</span>, num - pro) % mo, ans %= mo;</span><br><span class="line">                &#125;</span><br><span class="line">                pro = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Chainword"><a href="#F-Chainword" class="headerlink" title="F Chainword"></a>F <a href="https://codeforces.com/contest/1511/problem/F">Chainword</a></h2><p>题目大意：给了一个字典，有几个串，最后要使用这给出的几个串拼一个长为m的串，这样一个串具有以下三个属性(s，X，Y)，其中s是长为m的字符串，然后将这个长为m的串使用两种方式划分开，每一种方式划分出来的子串都要是字典中存在的串，第一种划分方式成为X，第二种划分方式成为Y。如果说两个串的三个属性中有任何一个不同，那么就说这两个串是不同的，最终要求出的是所有不同的串的数量。</p><p>解法：首先提一下，一张图的邻接矩阵自乘k步之后，i行j列表示的数就是从i点经过k步走到j点的方案数。</p><p>通过这样的性质，我们重新回来看这道题目，一个字符串具有三个属性，s，X，Y，第一个属性最好处理，只要字符不一样就好了，接下来我们来处理剩下的两个属性。我们将每一个不同的字符串都当做一个点，比如说字符串这三个aa，aaa，aab，现在我们将其看做三个点，当某一个串可以组成另一个串时，就在他们之间连一条边，比如点aa向点aaa连边，点aa向点aab连边，但是aaa显然不能组成aab，所以点aab和aaa之间是没有边的；而空字符串要向所有的单个字母构成的字符串连边。在我们将整个字符串问题转化为图的问题之后，就可以通过矩阵自乘来得到相应长度的方案。之后我们再回来看这个题目的两个属性，显然最后字符串结束的时候，也就是字符串的后缀一定是某一个字典串，故而我们可以通过字典树也就是trie树来简化图中的点的情况，我们只需要有用的字符串(因为如果我们构造出了某一个无法被字典树识别的子串，那么显然这个串也无法构成字典里的任何一个串或者被字典里的串构成)。如果我们只看属性X，那么用字典树中的ncnt个节点建图，将空字符串作为root点，且只给字典串中的结尾部分赋值为1，那么这样一个图的邻接矩阵自乘m步之后，矩阵中root行root列就是长为m的串，所有的划分的方案数。如果再添加第二个属性Y，无非就是将这两个属性分开来算，当两个属性同时满足的时候才赋值1，否则赋值0，整张图的点数就是ncnt*ncnt(每一个为了解决X属性的串都要对应一个解决Y属性的串)。</p><p>其实前边说了很多都是为了解释为什么矩阵快速幂在字典树上跑的正确性，真正到这个题，就是看当前满足X属性的串x和满足Y属性的串y，这样的二元组(x，y)如何向下转移。为了满足s属性，我们枚举下一个字符d，而在x串后接字符d组成的新串我们设它为dx，同理，y对应的就是dy，假如dx和dy都是完整的字典串(意味着划分到这里就划了一下，下个字符开始就是新的一个字典串了)，那么可以直接向(root,root)也就是情况x串和y串可以通过下一个字符d转移到答案；同理假如dx是一个字典串，那么可以向(root,dy)转移(即x这里划分划了一下，但是Y没有划分开)；假如dy是一个字典串，那么可以向(dx,root)转移；当然也可以继续向下转移(dx,dy)，也就是在这里X和Y都没有划分。</p><p>在得到这样的初始矩阵之后只需要自乘m步最后输出root行root列的答案就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">55</span>], ch[<span class="number">55</span>][<span class="number">55</span>], ncnt, cnt, rt;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; tu;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">&#125;ans;</span><br><span class="line"></span><br><span class="line">Mat <span class="keyword">operator</span> * (<span class="keyword">const</span> Mat &amp;x, <span class="keyword">const</span> Mat &amp;y)&#123;</span><br><span class="line">Mat ret;</span><br><span class="line"><span class="built_in">memset</span>(ret.a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ret.a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">ret.a[i][j] += <span class="number">1ll</span> * x.a[i][k] * y.a[k][j] % mo, ret.a[i][j] %= mo;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">qpow</span><span class="params">(Mat x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">Mat ret;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">ret.a[i][j] = (i == j);</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">x = x * x, y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tu[&#123;x, y&#125;]) <span class="keyword">return</span> tu[&#123;x, y&#125;];</span><br><span class="line">    tu[&#123;x, y&#125;] = ++cnt;</span><br><span class="line">    <span class="keyword">int</span> pro = cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line"><span class="keyword">if</span>(ch[x][i] &amp;&amp; ch[y][i])&#123;</span><br><span class="line"><span class="keyword">int</span> dx = ch[x][i], dy = ch[y][i];</span><br><span class="line">ans.a[pro][<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>)] += num[dx] * num[dy];</span><br><span class="line">ans.a[pro][<span class="built_in">dfs</span>(dx, <span class="number">0</span>)] += num[dy];</span><br><span class="line">ans.a[pro][<span class="built_in">dfs</span>(<span class="number">0</span>, dy)] += num[dx];</span><br><span class="line">ans.a[pro][<span class="built_in">dfs</span>(dx, dy)] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pro;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; s, rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j: s)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!ch[rt][j - <span class="string">&#x27;a&#x27;</span>]) ch[rt][j - <span class="string">&#x27;a&#x27;</span>] = ++ncnt;</span><br><span class="line">            rt = ch[rt][j - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ++num[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>), ans = <span class="built_in">qpow</span>(ans, m), cout &lt;&lt; ans.a[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Chips-on-a-Board"><a href="#G-Chips-on-a-Board" class="headerlink" title="G Chips on a Board"></a>G <a href="https://codeforces.com/contest/1511/problem/G">Chips on a Board</a></h2><p>题目大意：nim游戏，n堆石子，每堆最多m个，q组询问，每次询问得到石子数目区间在[l,r]的石子堆共k堆，然后询问这k堆石子堆每堆石子数目都减去l的之后的k堆石子做nim游戏的答案，询问互相独立，当前做的操作不会影响别的询问(这里并没有按照原来的语言描述题面，换了数学意义等价的描述方式)。</p><p>解法：观察题面，发现每次实际上就是找一个区间，然后对区间的每一个数做差之后进行异或求异或和，那实际上通过O3优化，avx2指令集优化以及使用GUNC++17(64)，4e10的数据也会被优化的飞快，所以暴力就过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;avx2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">200005</span>], ans, l, r, x, ii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), a[n + <span class="number">1</span>] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>), <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r), x = l;</span><br><span class="line">        r = <span class="built_in">upper_bound</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, r) - a;</span><br><span class="line">        l = <span class="built_in">upper_bound</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, l) - a;</span><br><span class="line">        <span class="keyword">for</span>(ii = l; ii &lt; r; ++ii) ans ^= a[ii] - x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&quot;AB&quot;</span>[ans == <span class="number">0</span>]), ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非暴力解(感谢队友RRRR_wys)：</p><p>按位拆开，每一位都是互相不影响的。f[i][k] 表示从i开始向后延申2^k长度的区间的答案，实际上每个位置异或的数字范围是[0,2^k-1]，然后考虑用f[i][k-1]和f[i+1&lt;&lt;k-1][k-1]合并答案的时候，相当于后边这个区间整体值加上2^(k-1)，其他的低位不变，所以只用考虑 k-1 位的贡献，询问也同样的方式考虑，就得到结果。</p><p><del>这里并没有写这个做法（跑</del></p><p>就没有代码了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现场被队友hack了，掉分了(气呼呼</p><p>个人对这场构造题(B，D)的评价还是比较高的，不过现场没有看F题，之后补题的时候感觉有点。。。套路了？G可能出题人都没想到4e10也能跑过吧，有点偏离主旨了。</p><p><del>不过怎么说呢？指令集优化也是算法！</del></p><p>总的来说相比上一场，代码量就会有一部分提升。还行吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Educational-Codeforces-Round-107-Rated-for-Div-2-https-codeforces-com-contest-1511&quot;&gt;&lt;a href=&quot;#Educational-Codeforces-Round-107-Rated</summary>
      
    
    
    
    <category term="训练" scheme="http://sosupro.github.io/categories/%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="codeforces" scheme="http://sosupro.github.io/tags/codeforces/"/>
    
    <category term="cfcontest" scheme="http://sosupro.github.io/tags/cfcontest/"/>
    
  </entry>
  
  <entry>
    <title>Divide by Zero 2021 and Codeforces Round 714</title>
    <link href="http://sosupro.github.io/2021/04/23/Divide-by-Zero-2021-and-Codeforces-Round-714-Div-2-cf-contest1513/"/>
    <id>http://sosupro.github.io/2021/04/23/Divide-by-Zero-2021-and-Codeforces-Round-714-Div-2-cf-contest1513/</id>
    <published>2021-04-22T16:43:50.000Z</published>
    <updated>2021-04-22T16:50:31.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Divide-by-Zero-2021-and-Codeforces-Round-714-Div-2-https-codeforces-com-contest-1513"><a href="#Divide-by-Zero-2021-and-Codeforces-Round-714-Div-2-https-codeforces-com-contest-1513" class="headerlink" title="Divide by Zero 2021 and Codeforces Round #714 (Div. 2)(https://codeforces.com/contest/1513)"></a>Divide by Zero 2021 and Codeforces Round #714 (Div. 2)(<a href="https://codeforces.com/contest/1513">https://codeforces.com/contest/1513</a>)</h1><h2 id="A-Array-and-Peaks"><a href="#A-Array-and-Peaks" class="headerlink" title="A Array and Peaks"></a>A <a href="https://codeforces.com/contest/1513/problem/A">Array and Peaks</a></h2><p>题目大意：A就不写题意了。</p><p>解法：算一下最多的peak可能出现的次数，从左往右放数字就好，能放peak就放当前最大的数字，其他情况当前最小的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k, a[<span class="number">105</span>], up, dw;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; (n - <span class="number">1</span>) / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            up = n, dw = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k &amp;&amp; !(i &amp; <span class="number">1</span>)) a[i] = up--, k--;</span><br><span class="line">                <span class="keyword">else</span> a[i] = dw++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; (i == n ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-AND-Sequences"><a href="#B-AND-Sequences" class="headerlink" title="B AND Sequences"></a>B <a href="https://codeforces.com/contest/1513/problem/B">AND Sequences</a></h2><p>题目大意：B就不写题意了，注意当一个sequences是好的时候所有的划分都满足条件。</p><p>解法：显然若所有数二进制下某位均为1，该位无影响，若所有数二进制下某位有1有0，则第1个数和第n个数该位必为0，所以枚举头尾，中间n-2个数字直接排列就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, a[<span class="number">200005</span>], can[<span class="number">200005</span>], num[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ji[<span class="number">200005</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T, ji[<span class="number">1</span>] = ji[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">200000</span>; i++) ji[i] = (ji[i - <span class="number">1</span>] * i) % mo;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], can[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pro = <span class="number">1</span> &lt;&lt; j; num[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(a[i] &amp; pro) num[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pro = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>((a[i] &amp; pro) &amp;&amp; num[j] != n) can[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!can[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt) cout &lt;&lt; (<span class="number">1LL</span> * cnt * (cnt - <span class="number">1</span>) % mo) * ji[n - <span class="number">2</span>] % mo &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Add-One"><a href="#C-Add-One" class="headerlink" title="C Add One"></a>C <a href="https://codeforces.com/contest/1513/problem/C">Add One</a></h2><p>题目大意：C稍微写一点题意，每一次操作将一个数字的所有位数字+1,比如现在有一个数字19，进行一次操作就变成了210(9+1=10,将2位数10拆成2位),然后每组询问数字n经过m次操作之后得到的数字有多少位。</p><p>解法：实际上对于数字n来说每一位都是独立的，抓住这个性质之后直接预处理出对于0~9这9个数字单独一个数进行多少次操作后得到的位数，令dp[i][j]表示数字i经过j次操作之后是几位数，在计算这个的时候，再定义num[i][j]表示对于当前情况，操作了j次之后数字i的个数，具体的转移见代码，还是比较显然的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">10</span>][<span class="number">200005</span>], dp[<span class="number">10</span>][<span class="number">200005</span>], ans, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    num[x][<span class="number">0</span>] = <span class="number">1</span>, dp[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; i++)&#123;</span><br><span class="line">        dp[x][i] = (dp[x][i - <span class="number">1</span>] + num[<span class="number">9</span>][i - <span class="number">1</span>]) % mo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">            num[j][i] = (num[(j - <span class="number">1</span> + <span class="number">10</span>) % <span class="number">10</span>][i - <span class="number">1</span>]) % mo;</span><br><span class="line">        num[<span class="number">1</span>][i] = (num[<span class="number">1</span>][i] + num[<span class="number">9</span>][i - <span class="number">1</span>]) % mo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) <span class="built_in">init</span>(i);</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(n) ans = (ans + dp[n % <span class="number">10</span>][m] ) % mo, n /= <span class="number">10</span>;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-GCD-and-MST"><a href="#D-GCD-and-MST" class="headerlink" title="D GCD and MST"></a>D <a href="https://codeforces.com/contest/1513/problem/D">GCD and MST</a></h2><p>题目大意：D题给了一个序列，条件1：若某一段连续的数字的gcd是这段数字中最小的数字(设为w)，则这段数字的左端点向右端点连一条权值为w的边。条件2：若某两个点i,j(i&lt;j)相邻，则从i向j连一条权值为给定值P的边。最后在所有连边连出来的图上求最小生成树。</p><p>解法：显然，假如某一条边的因为满足条件1产生的，而这条边的权值w&gt;P，则这样一条边是一定不优的。所以我们从小到大枚举满足w&lt;P的边，加完这些边之后做MST就是答案。而这样的边也会有很多，所以继续模拟我们刚才得到的算法，当前我们枚举的是最小值w1，最小值向左有一段数和最小值的gcd是最小值本身，向右也有这么一段数，即我们去找w1向左连续的、满足和w1的gcd为w1的最左的位置为l，向右同理的找到右端点r，那么l，r这一个区间实际上是可以通过r-l条权值为w1的边全部连通的。而由于我们枚举的顺序是从小到大，假如我们枚举到一个新的数字w2，若w2连接到了一个已经被连接好的区间内，之后w2就无法在这个方向继续扩展了(因为继续扩展的话不会更优，之前扩展的边权一定不大于当前的边权)。所以综上，一开始整个序列我们令其为n个长度为1的区间(即每个数都是一个长为1的区间)，我们从小到大枚举边权，依次针对这个边权从它所处的位置向左和向右分别扩展区间，连接到最后没有连起来的区间之间全部通过边权为P的边相连即可，这样的生成树就是一棵MST。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">po</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;p[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, v[<span class="number">200005</span>], a[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> P, ans, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(po x, po y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; P, cnt = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], p[i].a = a[i], p[i].b = i, v[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; p[i].a &lt; P; i++) <span class="keyword">if</span>(!v[p[i].b])&#123;</span><br><span class="line">            v[p[i].b] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p[i].b + <span class="number">1</span>; j &lt;= n &amp;&amp; __gcd(a[j], a[p[i].b]) == a[p[i].b]; j++)&#123;</span><br><span class="line">                ans += p[i].a, cnt--;</span><br><span class="line">                <span class="keyword">if</span>(v[j]) <span class="keyword">break</span>;</span><br><span class="line">                v[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p[i].b - <span class="number">1</span>; j &amp;&amp; __gcd(a[j], a[p[i].b]) == a[p[i].b]; j--)&#123;</span><br><span class="line">                ans += p[i].a, cnt--;</span><br><span class="line">                <span class="keyword">if</span>(v[j]) <span class="keyword">break</span>;</span><br><span class="line">                v[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans + cnt * P &lt;&lt; endl, ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Cost-Equilibrium"><a href="#E-Cost-Equilibrium" class="headerlink" title="E Cost Equilibrium"></a>E <a href="https://codeforces.com/contest/1513/problem/E">Cost Equilibrium</a></h2><p>题目大意：一个序列，要通过一些操作让这个序列的每一个数字都变成同样的。操作是选择两个位置i,j，然后给a[i]加上x(正整数)并且给a[j]减去x，而这样的操作存在一个限制：当某一个数被变大之后，他就不可能再被变小。而这样一次操作会产生|i-j|*x的代价，若给出序列的某一个排列方式排完之后，无论怎样操作使得最终序列的每一个数字都变成同样的，所花费的代价都是相等的话，这样的排列就是棒的，要求给出这样的排列的数量。</p><p>解法：观察题面，对于一个既定的数组而言，其最小代价可通过贪心得到，既从左到右，每一个不满足当前情况的数（小于平均值）去寻找最近的大于平均值的数进行满足既可。反之，最大代价也是同样的方法，只不过寻找最远的大于平均值的数进行满足既可。<br>所以，当最小值与最大值相同时，大胆猜测，两部分若个数均大于1，则这两部分均连续(简单证一下，假如不连续，那么一定存在某一个部分的数字，左边和右边都有另一部分的数字，这个时候就可以通过上述的贪心操作得到代价不同的方式，不符合题意；或者找这样一个情况然后拿代价产生的公式化简一下，也可以证得)。若某一部分仅有一个，则所有情况均可(因为所有选的点对中一定有这个点，上边的产生代价的公式随手化一下就可以证明)。最后处理不需要操作的点，假如有num3个，直接给答案乘以n个位置选num3个位置的方案数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ji[<span class="number">200005</span>], inv[<span class="number">200005</span>], num1, num2, num3, sum, a[<span class="number">200005</span>], n, ans, Inv = <span class="number">1</span>, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret *= x, ret %= mo;</span><br><span class="line">        x *= x, x %= mo, y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ji[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; i++) ji[i] = ji[i - <span class="number">1</span>] * i % mo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200000</span>; i++) inv[i] = <span class="built_in">qpow</span>(ji[i], mo - <span class="number">2</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], sum += a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n), a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">-1</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == a[i - <span class="number">1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Inv *= inv[cnt], Inv %= mo;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num1 += a[i] &lt; (sum / n), num2 += a[i] &gt; (sum / n);</span><br><span class="line">    num3 = n - num1 - num2;    </span><br><span class="line">    <span class="keyword">if</span>(sum / n * n != sum) ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num1 == <span class="number">0</span> || num2 == <span class="number">0</span>) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num1 == <span class="number">1</span> || num2 == <span class="number">1</span>) ans = ji[n] * Inv % mo;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans = <span class="number">2</span> * Inv % mo;</span><br><span class="line">        ans = ans * ji[num1] % mo * ji[num2] % mo * ji[num3] % mo;</span><br><span class="line">        ans = ans * ji[n] % mo * inv[num3] % mo * inv[n - num3] % mo;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="F-Swapping-Problem"><a href="#F-Swapping-Problem" class="headerlink" title="F Swapping Problem"></a>F <a href="https://codeforces.com/contest/1513/problem/F">Swapping Problem</a></h2><p>题目大意：俩数组a，b，对应位置元素做差的和是代价，现在可以选择b数组中的两个位置进行元素交换，问交换后的最小代价(原题面的数学描述比较简洁)。</p><p>解法：观察交换，假如选择的两个位置i,j，ai&lt;bi且aj&lt;bj，则这样交换并不会更优，那么实际上选择的方案对是i位置和j位置，元素大小是要反着的，即  ai&gt;bi且aj&lt;bj  或  ai&lt;bi且aj&gt;bj  这样的(这里其实并不需要严格小于或者大于，等于也是可以的，反正最后取最优情况的时候假如全是等号贡献也是0，不影响)。所以我们就把原来的点对(因为位置绑定了a和b数组的对应元素，就把这个同一位置的俩数当做点对)分成两个集合，分类依据是a数组的该元素是否大于b数组的对应元素，分完类之后按照我们之前得到的条件，答案一定是第一个集合出一个位置，第二个集合出一个位置。之后就是怎么得到最优的答案了，假设没有经过修改的答案是sum，我们选择的点对是上述的i和j(不妨设i是第一个集合，j是第二个集合，再不妨设bi≤aj≤ai≤bj，通过依据点对中最小的数字排序可以做到这一点)，那么修改过后的答案就是sum-2*(ai-aj)，至于剩下维护这个的最大值以及对上述“不妨设”的其他设定情况，可以通过分类讨论解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum, ans, n, mx[<span class="number">2</span>];;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">po</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, z;</span><br><span class="line">&#125;p[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(po x, po y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i].x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i].y, sum += <span class="built_in">abs</span>(p[i].y - p[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(p[i].x &gt; p[i].y)</span><br><span class="line">        p[i].z = <span class="number">1</span>, <span class="built_in">swap</span>(p[i].x, p[i].y);</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(mx[!p[i].z], p[i].y) - p[i].x);</span><br><span class="line">        mx[p[i].z] = <span class="built_in">max</span>(mx[p[i].z], p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">cout &lt;&lt; sum - ans * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然这场是印度场，但是总的来说题面的表达还是十分简洁以及高效的。而所有问题都可以通过巧妙的解法，以一个很小的代码量完成，并没有出现题面恶心人\解法恶心人的情况，故而这套题坐下来的感觉还是十分不错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Divide-by-Zero-2021-and-Codeforces-Round-714-Div-2-https-codeforces-com-contest-1513&quot;&gt;&lt;a href=&quot;#Divide-by-Zero-2021-and-Codeforces-R</summary>
      
    
    
    
    <category term="训练" scheme="http://sosupro.github.io/categories/%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="codeforces" scheme="http://sosupro.github.io/tags/codeforces/"/>
    
    <category term="cfcontest" scheme="http://sosupro.github.io/tags/cfcontest/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 712</title>
    <link href="http://sosupro.github.io/2021/04/23/Codeforces-Round-712-Div-2-cf-contest-1504/"/>
    <id>http://sosupro.github.io/2021/04/23/Codeforces-Round-712-Div-2-cf-contest-1504/</id>
    <published>2021-04-22T16:43:19.000Z</published>
    <updated>2021-04-22T16:50:42.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-712-Div-2-cf-contest-1504"><a href="#Codeforces-Round-712-Div-2-cf-contest-1504" class="headerlink" title="Codeforces Round #712 (Div. 2)(cf contest 1504)"></a><a href="https://codeforces.com/contest/1504">Codeforces Round #712 (Div. 2)</a>(cf contest 1504)</h1><h2 id="A-Deja-Vu"><a href="#A-Deja-Vu" class="headerlink" title="A Déjà Vu"></a>A <a href="https://codeforces.com/contest/1504/problem/A">Déjà Vu</a></h2><p>题目大意：给字符串添加一个字母a让它不是一个回文串。</p><p>解法：扫一遍，只要能加就加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, ans, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; s + <span class="number">1</span>, n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(s[n - i + <span class="number">1</span>] != <span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == ans) cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cout &lt;&lt; s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Flip-the-Bits"><a href="#B-Flip-the-Bits" class="headerlink" title="B Flip the Bits"></a>B <a href="https://codeforces.com/contest/1504/problem/B">Flip the Bits</a></h2><p>题目大意：给一个01串，现有操作就是对于当前它的前缀，假如0和1的个数相等，就可以把0变1把1变0，最后要通过操作将A串变成B串。</p><p>解法：观察操作性质，发现任何一次操作都不影响别的点是否可以操作，所以从后往前扫，如果当前A串和B串不匹配，就翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, ans, n, num[<span class="number">2</span>][<span class="number">300005</span>], fl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">300005</span>], t[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s + <span class="number">1</span> &gt;&gt; t + <span class="number">1</span>, ans = <span class="number">1</span>, fl = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num[<span class="number">0</span>][i] = num[<span class="number">0</span>][i - <span class="number">1</span>], num[<span class="number">1</span>][i] = num[<span class="number">1</span>][i - <span class="number">1</span>], num[s[i] == <span class="string">&#x27;1&#x27;</span>][i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i] != t[i]) == (fl))&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[<span class="number">1</span>][i] != num[<span class="number">0</span>][i])&#123;</span><br><span class="line">                    ans = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> fl = !fl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(ans ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Balance-the-Bits"><a href="#C-Balance-the-Bits" class="headerlink" title="C Balance the Bits"></a>C <a href="https://codeforces.com/contest/1504/problem/C">Balance the Bits</a></h2><p>题目大意：需要构造两个可以匹配的括号序列（包含左右括号，括号序列的匹配就是，哎呀去百度一下这里就不写了），首先每个括号序列需要满足给定的位置括号是一样的，剩下位置括号都是相反的（可以看样例，样例是很形象的）。</p><p>解法：实际上说是构造两个个序列，但是由于这两个序列的对应位置要么相同要么不同，所以是两个序列对应的（因为左括号反过来只有右括号一种情况）。之后考虑普通括号序列匹配的条件，我们有了num[右][i]&gt;=num[左][i]且num[右][n]==num[左][n]，其中num[右][i]代表从左到第i个位置，右括号的数量，num[左][i]同理。之后再根据两个序列有一部分是一样的，一部分是截然相反的，那么对于第一个序列，num[右][一样][i]代表从左边到第i个位置，两个序列中都一样的右括号的数量，我们就有了：对于第一个序列num[右][一样][i]+num[右][不一样][i]&gt;=num[左][一样][i]+num[左][不一样][i]，而因为所有不一样的元素都是反着的，所以对于第二个序列我们又有了num[右][一样][i]+num[左][不一样][i]&gt;=num[左][一样][i]+num[右][不一样][i]，而在当i=n时，我们又有num[右][一样][i]+num[右][不一样][i]==num[左][一样][i]+num[左][不一样][i]且num[右][一样][i]+num[左][不一样][i]==num[左][一样][i]+num[右][不一样][i]。</p><p>故而根据上述的式子，我们可以选取一种贪心的策略，那就是尽量确保num[右][一样][i]&gt;num[左][一样][i]且num[右][不一样][i]==num[左][不一样][i]，这样才能更好的满足上述的几个式子，所以我们在两个序列都相同的位置优先填左括号，左括号填完之后再填右括号，而对于两个序列不一样的位置 ，我们一左一右这样填，假如这样填到最后都没法满足条件，那么也就不存在别的情况可以满足了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, ans, n, num[<span class="number">2</span>], fl, w[<span class="number">2</span>][<span class="number">2</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">300005</span>], t[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s + <span class="number">1</span>, fl = ans = <span class="number">1</span>, cnt = num[<span class="number">0</span>] = num[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num[s[i] == <span class="string">&#x27;1&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                cnt++, t[i] = (cnt &lt;= (num[<span class="number">1</span>] / <span class="number">2</span>)) ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t[i] = fl ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>, fl = !fl;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                w[<span class="number">1</span>][t[i] == <span class="string">&#x27;)&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                w[<span class="number">0</span>][t[i] == <span class="string">&#x27;)&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(w[<span class="number">1</span>][<span class="number">0</span>] + w[<span class="number">0</span>][<span class="number">0</span>] &lt; w[<span class="number">1</span>][<span class="number">1</span>] + w[<span class="number">0</span>][<span class="number">1</span>] || w[<span class="number">1</span>][<span class="number">0</span>] + w[<span class="number">0</span>][<span class="number">1</span>] &lt; w[<span class="number">1</span>][<span class="number">1</span>] + w[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(w[<span class="number">1</span>][<span class="number">0</span>] != w[<span class="number">1</span>][<span class="number">1</span>] || w[<span class="number">0</span>][<span class="number">1</span>] != w[<span class="number">0</span>][<span class="number">0</span>]) ans = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(ans ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; t[i]; cout &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>) t[i] = t[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; t[i]; cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-3-Coloring"><a href="#D-3-Coloring" class="headerlink" title="D 3-Coloring"></a>D <a href="https://codeforces.com/contest/1504/problem/D">3-Coloring</a></h2><p>题目大意：交互题，n*n的方格染色，一共有三种颜色，相邻的格子不能有同样的颜色，每次操作是首先程序给我们一个不能使用的颜色，我们来选择剩下的两种颜色之一，输出给哪个格子染这个颜色，最终要求把所有格子都合法的染完。</p><p>解法：简单的看一下n*n的格子图，我们可以把整张图可以将所有格子分为两类，分类方法就是斜线，显然斜着的一行格子之间不会有任何点相邻，而奇数斜线行格子之间的所有格子都不相邻，偶数行也同理。</p><p>1 0 1</p><p>0 1 0</p><p>1 0 1</p><p>就像这样将所有点分为两类。由于这两类之中，每一类任两个点都不相邻，所以我们可以使用以下策略：用颜色1来填第一类点，那么只要程序禁用颜色1，我们就用颜色2填第二类。必然会有一类先填完，而剩下如果是第一类，就用颜色1和颜色3来填，由于有两种颜色他没办法全部禁用，同理如果剩下的是第二类，我们就用颜色2和颜色3来填剩下的第二类格子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, x, y, b, c1, c2, l1 = <span class="number">1</span>, l2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n, T = n * n, c1 = <span class="number">1</span>, c2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt;= n &amp;&amp; l2 &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m != <span class="number">1</span>)&#123;</span><br><span class="line">                x = l1, y = c1, c1 += <span class="number">2</span>, b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(c1 &gt; n) l1++, c1 = <span class="number">1</span> + !(l1 &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x = l2, y = c2, c2 += <span class="number">2</span>, b = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(c2 &gt; n) l2++, c2 = <span class="number">1</span> + (l2 &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l1 &lt;= n)&#123;</span><br><span class="line">                    x = l1, y = c1, c1 += <span class="number">2</span>, b = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c1 &gt; n) l1++, c1 = <span class="number">1</span> + !(l1 &amp; <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l2 &lt;= n)&#123;</span><br><span class="line">                    x = l2, y = c2, c2 += <span class="number">2</span>, b = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c2 &gt; n) l2++, c2 = <span class="number">1</span> + (l2 &amp; <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(l1 &lt;= n)&#123;</span><br><span class="line">                    x = l1, y = c1, c1 += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c1 &gt; n) l1++, c1 = <span class="number">1</span> + !(l1 &amp; <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l2 &lt;= n)&#123;</span><br><span class="line">                    x = l2, y = c2, c2 += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c2 &gt; n) l2++, c2 = <span class="number">1</span> + (l2 &amp; <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                b = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl, cout.<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Travelling-Salesman-Problem"><a href="#E-Travelling-Salesman-Problem" class="headerlink" title="E Travelling Salesman Problem"></a>E <a href="https://codeforces.com/contest/1504/problem/E">Travelling Salesman Problem</a></h2><p>题目大意：有n个点，任两个点i,j之间的通行花费是max(ci,aj-ai)，问从1点出发遍历所有点均一次最后回到1点的方案。</p><p>解法：观察题面，实际上就是完全图然后找一个长为n的最小环，每个点都被遍历一次，那么实际上他就和1作为起点关系不大了，因为它是一个环。那么朴素的枚举起点显然是过不了的，我们考虑这个加边的时候取通行花费的max(ci,aj-ai)，显然如果当前的点ai很大，那么它通向所有的点的花费都是ci，而每个点出发的花费最少就是ci，于是假如我们的起点是ai最大的点，那么可以通过对剩下的点的a数组进行排序做到每一条路径花费都是最少的。但是因为这是个环，那么现在问题出现在了怎么从最小的点回到最大的点上，如果直接回的话可能会很劣，所以我们可以转换思路，先使用最小的代价从a值最小的点走到a值最大的点，然后再从a最大的点走去其他点，而最终一点是会落在a最小的点上，这样是比刚才的方法更优的。</p><p>由于ci的存在，实际上对于一个点来说所有满足于aj&lt;=ai+ci的点代价都是最优的，那么我们就从最小的点开始看他全部通过最小代价能走的最大的点是谁，之后从那个点开始继续向上找，直到找到a值最大的点（也就是查找max{aj+cj  (j满足aj∈[0,ai+ci])  然后令i=j，重复操作}）。假如当前ai+ci就是最大的，那就要产生额外花费了，就得去查找第一个大于ai+ci的aj，然后令i=j重复上述操作了。</p><p>这个做法的正确性是显然的，为了朴素的维护这样的一个做法可以使用权值线段树，然后就做出来了。不过好像这题是有On做法的，也有更加方便的写法，但是我个人比较笨，没有去往哪里想，估计也想不到，就这样在cf上用Onlogn水过去了hhhhhh。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">po</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l, r, w;</span><br><span class="line">&#125;t[<span class="number">200005</span> * <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, n, cnt = <span class="number">1</span>, rt, mx, a[<span class="number">300005</span>], c[<span class="number">300005</span>], b[<span class="number">300005</span>], mn = <span class="number">3000000001</span>, st = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> w, <span class="keyword">long</span> <span class="keyword">long</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        t[k].w = <span class="built_in">max</span>(t[k].w, w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(L, mid, x, w, t[k].l);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(mid + <span class="number">1</span>, R, x, w, t[k].r);</span><br><span class="line">    t[k].w = <span class="built_in">max</span>(t[t[k].l].w, t[t[k].r].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">que</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r, <span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L == l &amp;&amp; R == r) <span class="keyword">return</span> t[k].w;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">que</span>(L, mid, l, r, t[k].l);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">que</span>(mid + <span class="number">1</span>, R, l, r, t[k].r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">que</span>(L, mid, l, mid, t[k].l), <span class="built_in">que</span>(mid + <span class="number">1</span>, R, mid + <span class="number">1</span>, r, t[k].r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; c[i];</span><br><span class="line">        b[i] = a[i], ans += c[i], mx = <span class="built_in">max</span>(mx, a[i] + c[i]);</span><br><span class="line">        <span class="keyword">if</span>(mn &gt;= a[i]) mn = a[i], st = i; </span><br><span class="line">        rt = <span class="number">1</span>, <span class="built_in">change</span>(<span class="number">0LL</span>, <span class="number">3000000000LL</span>, a[i], a[i] + c[i], rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = a[st] + c[st], pro;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pro = <span class="built_in">que</span>(<span class="number">0LL</span>, <span class="number">3000000000LL</span>, <span class="number">0LL</span>, now, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(now == mx) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(pro == now)&#123;</span><br><span class="line">            pro = <span class="built_in">upper_bound</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>, now) - b;</span><br><span class="line">            pro = b[pro], ans += pro - now;</span><br><span class="line">        &#125;</span><br><span class="line">        now = <span class="built_in">max</span>(now, pro);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Flip-the-Cards"><a href="#F-Flip-the-Cards" class="headerlink" title="F Flip the Cards"></a>F <a href="https://codeforces.com/contest/1504/problem/F">Flip the Cards</a></h2><p>题目大意：n张卡片，一共是有1~2n，2n个数字印在卡片的正反两面上，操作是可以翻转某些卡片，最终要求所有正面的数字排完序之后，背面的数字是相反的大小顺序。</p><p>解法：假如某一张卡片上印的两个数字都大于n或者小于等于n，那这种情况显然不合法（证明还是比较好证的，设一下算一下就能看出矛盾了）。所以现在我们的每张卡片都是印着一个1<del>n的和一个n+1</del>2n的数字。我们首先假装所有的1<del>n都朝同一面，并且是按从1</del>n有序排好的，那么对于这样的情况来说，假如第一张卡片翻转了，它就一定出现在当前序列的最后，因为它的另一面显然比n要大，而这一面显然比n+1要小，进而当我们翻转第二张时，它一定根据大小关系放在刚刚翻转的那张前边，以此类推。于是我们可以得到一个合法的序列（假如翻转的时候放不到指定的位置，那整个情况都是不合法的），接下来讨论最优解，实际上我们再观察最终排好的序列，会发现整个序列的可以分成几个段的，每一段之间都互不影响，也就是说如果我们有k张牌，k张牌里1<del>n区间内的最大值-最小值是k且n+1</del>2n区间内的最大值减去最小值也是k，那么这个区间内的大小关系就只要在这个区间内自己处理就好。最后我们回到这个问题，最优解就是各个区间的最优解加到一起，而区间内的最优值就是假如刚才找出的情况中：要翻的卡片数多，我们就把所有不要翻转的翻一下；如果要翻的卡片数小我们就直接翻转这些卡片。最终我们扫一遍，扫到一个区间就给答案加上这个区间的最小值，就得到了答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; bits/stdc++.h &gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, x, y, a[<span class="number">400005</span>], b[<span class="number">400005</span>], c[<span class="number">400005</span>], cnt, fl, pro[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), fl = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), a[x] = y, a[y] = x, b[x] = b[y] = (x &lt; y);</span><br><span class="line">    x = y = <span class="number">2</span> * n + <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; y || a[i] &lt;= n) fl = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt; x) x = a[i], c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> y = a[i], c[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">2</span> * n - i + <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(cnt &lt;= i) pro[c[cnt] ^ b[cnt]]++, cnt++;</span><br><span class="line">ans += <span class="built_in">min</span>(pro[<span class="number">0</span>], pro[<span class="number">1</span>]), pro[<span class="number">0</span>] = pro[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(fl, ans));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>后边还有div1的两道题，实在是做不动了就先放着了，只看div2方面的题目还是比较不错的，类型比较丰富，需要想的内容要比代码写的内容多得多。蛮不错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Codeforces-Round-712-Div-2-cf-contest-1504&quot;&gt;&lt;a href=&quot;#Codeforces-Round-712-Div-2-cf-contest-1504&quot; class=&quot;headerlink&quot; title=&quot;Codeforc</summary>
      
    
    
    
    <category term="训练" scheme="http://sosupro.github.io/categories/%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="codeforces" scheme="http://sosupro.github.io/tags/codeforces/"/>
    
    <category term="cfcontest" scheme="http://sosupro.github.io/tags/cfcontest/"/>
    
  </entry>
  
  <entry>
    <title>CodeCraft-21 and Codeforces Round 711</title>
    <link href="http://sosupro.github.io/2021/04/23/CodeCraft-21-and-Codeforces-Round-711-Div-2-cf-contest-1498/"/>
    <id>http://sosupro.github.io/2021/04/23/CodeCraft-21-and-Codeforces-Round-711-Div-2-cf-contest-1498/</id>
    <published>2021-04-22T16:42:09.000Z</published>
    <updated>2021-04-22T16:45:28.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeCraft-21-and-Codeforces-Round-711-Div-2-cf-contest-1498"><a href="#CodeCraft-21-and-Codeforces-Round-711-Div-2-cf-contest-1498" class="headerlink" title="CodeCraft-21 and Codeforces Round #711 (Div. 2)(cf contest 1498)"></a><a href="https://codeforces.com/contest/1498">CodeCraft-21 and Codeforces Round #711 (Div. 2)</a>(cf contest 1498)</h1><h2 id="A-GCD-Sum"><a href="#A-GCD-Sum" class="headerlink" title="A GCD Sum"></a>A <a href="https://codeforces.com/contest/1498/problem/A">GCD Sum</a></h2><p>题目大意：A没啥好说的。</p><p>解法：就硬找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> pro = n, ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pro) ret += (pro % <span class="number">10</span>), pro /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(__gcd(n, ret) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Box-Fitting"><a href="#B-Box-Fitting" class="headerlink" title="B Box Fitting"></a>B <a href="https://codeforces.com/contest/1498/problem/B">Box Fitting</a></h2><p>题目大意：有一些1×2^？的块，平放，放进一个盒子，给了盒子的宽，求盒子的高。</p><p>解法：贪心，能放多大就放多大的块，完了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, m, ans, a;</span><br><span class="line"></span><br><span class="line">map &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), num[a]++;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">int</span> pro = <span class="number">1</span>, ret = m;</span><br><span class="line">            <span class="keyword">while</span>(pro &lt;= m) pro &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            pro &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(ret &amp;&amp; n &amp;&amp; pro)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[pro]) ret -= pro, num[pro]--, n--;</span><br><span class="line">                <span class="keyword">while</span>((pro &gt; ret || !num[pro]) &amp;&amp; pro) pro &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans), ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Planar-Reflections"><a href="#C-Planar-Reflections" class="headerlink" title="C Planar Reflections"></a>C <a href="https://codeforces.com/contest/1498/problem/C">Planar Reflections</a></h2><p>题目大意：给n块平行的平面镜，假如有一束强度为k的光射向镜子，将沿着射入方向穿过镜子并额外向反向反射出一束强度为k-1的光，当光强度降为0就消失了。假如某束光的前进方向没有镜子，就是射向外界的。问当一束强度为k的光从最左侧射入，求最终射向外界的光的总数。</p><p>解法：观察题面，n和k都比较小，而且实际上由于光不可能从镜子中间出现，只能从左右射入，所以最为关键的信息就是连续的一段镜子的数目以及光的强度和从左向射入还是从右向射入。所以我们可以直接枚举光强，f[i][j][k]表示从最右边到第i块镜子这么连续的一段镜子区间，j是光强，k是射入方向，同理s[i][j][k]是从最左边到第i块镜子这样连续的区间，j是光强，k是射入方向，之后就转移一下就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T, n, m, f[<span class="number">1005</span>][<span class="number">1005</span>][<span class="number">2</span>], s[<span class="number">1005</span>][<span class="number">1005</span>][<span class="number">2</span>]; <span class="comment">//0 左 1 右</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">            f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = <span class="number">0</span>, s[i][j][<span class="number">0</span>] = s[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[i][<span class="number">1</span>][<span class="number">0</span>] = f[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) f[<span class="number">0</span>][i][<span class="number">0</span>] = s[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            s[i][<span class="number">1</span>][<span class="number">0</span>] = (s[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + f[i][<span class="number">1</span>][<span class="number">0</span>]) % mo;</span><br><span class="line">            s[i][<span class="number">1</span>][<span class="number">1</span>] = (s[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + f[i][<span class="number">1</span>][<span class="number">1</span>]) % mo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= m; k ++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            f[i][k][<span class="number">0</span>] = <span class="number">1</span> + (f[i][k][<span class="number">0</span>] + s[i + <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">1</span>] - s[<span class="number">1</span>][k - <span class="number">1</span>][<span class="number">1</span>]) % mo;</span><br><span class="line">            f[i][k][<span class="number">1</span>] = <span class="number">1</span> + (f[i][k][<span class="number">1</span>] + s[n - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] + mo) % mo;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) f[i][k][<span class="number">1</span>] = (f[i][k][<span class="number">1</span>] - s[i - <span class="number">2</span>][k - <span class="number">1</span>][<span class="number">0</span>] + mo) % mo;</span><br><span class="line">            s[i][k][<span class="number">0</span>] = (s[i - <span class="number">1</span>][k][<span class="number">0</span>] + f[i][k][<span class="number">0</span>]) % mo;</span><br><span class="line">            s[i][k][<span class="number">1</span>] = (s[i - <span class="number">1</span>][k][<span class="number">1</span>] + f[i][k][<span class="number">1</span>]) % mo;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[<span class="number">1</span>][m][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Bananas-in-a-Microwave"><a href="#D-Bananas-in-a-Microwave" class="headerlink" title="D Bananas in a Microwave"></a>D <a href="https://codeforces.com/contest/1498/problem/D">Bananas in a Microwave</a></h2><p>题目大意：有两种操作方式，分别是给当前数加上一个数和给当前一个数乘以一个数（这里这个数字可能是小数，所以所有操作的结果都向上取整），每个操作方式都有一个可以执行的次数。初始状态是0。最终要求的是1~m中的每个数字，都是最少可以使用前几个操作方式组成（具体细节还挺复杂，题面有更详细的描述）。</p><p>解法：继续暴力，先说加法，观察加法我们发现实际上假如某一个数字之前已经被组成了，那么他接下来很多次操作实际上所组成的数字在模加数的一一下都是相同的，就可以使用这一性质对加法进行优化，使其达到Om的级别。再说乘法，假如当前我们某个数字x乘以现在操作的一个数字p，发现结果的数字y在之前的操作中已经被得到过了，那么y也一定会在这次操作中不断的乘以p，所以到这一步我们就可以直接退出循环，直到当前的数字是y时，再用y和p去乘，这样每个乘法操作也是Om级别的（因为所有m个数字，每个数字最多会被标记1次，而每个数字扫到一个已经被标记过的数字就会结束循环，总数是2m）。</p><p>应该还有dp的写法，但是一开始没往这里想，是从纯暴力改对的，显得代码比较长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;O3&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, a, c, ans[<span class="number">400005</span>], now[<span class="number">400005</span>], ret[<span class="number">400005</span>], mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans)); ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">double</span> pro = b / <span class="number">100000.0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> bb = b / <span class="number">100000</span>;</span><br><span class="line">        bb = bb * <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ret));</span><br><span class="line">            <span class="built_in">memset</span>(now, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(now));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">0</span>; j &lt;= m; j++) now[j] = (ans[j] != <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> prov;</span><br><span class="line">            <span class="keyword">if</span>(bb &lt; b) prov = bb / <span class="number">100000</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> prov = bb / <span class="number">100000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!now[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ret[j % prov]) ans[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ret[j % prov]++;</span><br><span class="line">                <span class="keyword">if</span>(j - c * prov &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(now[j - c * prov]) ret[j % prov]--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(now, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(now));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">0</span>; j &lt;= m; j++) now[j] = (ans[j] != <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span>(now[j])&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> cc  = j * b;</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, j);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> last = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k = <span class="number">1</span>; k &lt;= c; k++)&#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> pwp;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ccc = cc / <span class="number">100000</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ccc * <span class="number">100000</span> &lt; cc) pwp = ccc + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> pwp = ccc;</span><br><span class="line">                    <span class="keyword">if</span>(pwp &gt; m) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(last == pwp) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ans[pwp] != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    last = pwp;</span><br><span class="line">                    <span class="keyword">if</span>(ans[pwp] == <span class="number">-1</span>)&#123;</span><br><span class="line">                        ans[pwp] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cc = pwp * b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Two-Houses"><a href="#E-Two-Houses" class="headerlink" title="E Two Houses"></a>E <a href="https://codeforces.com/contest/1504/problem/E">Two Houses</a></h2><p>题目大意：朴素的交互题，有n个点，任两个点i,j之间通过有向边相连，但是我们不知道边的方向，现在题目一开始给定了每个点的入度，要求出可以互相到达的一对入度差最大的点。我们每次可以向程序询问一对点是否可以互相到达，如果程序回复我们可以到达，那么我们再也无法进行询问。</p><p>解法：首先，由于两点要可以互相到达，那么显然入度拉满的点或者出度拉满的点都不行。所以我们把所有这样的点都删掉（有的点会因为删掉了别的点之后变成当前图中入度拉满或者出度拉满的点，这个也是需要处理的），在删掉所有点之后，我们大胆猜测，如果从一个入度很大的点（意味着出度很小）都能到一个入度很小的点（出度很大），那么这两个点反过来应该会更容易到达，因为反过来就是从一个出度很大到一个入度很大的点，于是我们就这样贪心的求一下，发现它居然过了hhhh。</p><p>之后我看题解有的dalao好像都没有询问就得出了答案，但是我懒了一下没有看他们怎么做的orz太强啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, num[<span class="number">505</span>], up, cnt;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pp[<span class="number">505</span>*<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a, p[i] = &#123;a, i&#125;, num[a]++;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt;= up)&#123;</span><br><span class="line">        up += num[cnt], cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n), cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(p[i].first &gt; up)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt; i; j--) <span class="keyword">if</span>(p[j].first &gt; up)&#123;</span><br><span class="line">            pp[++cnt] = &#123;p[i].first - p[j].first, &#123;p[j].second, p[i].second&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(pp + <span class="number">1</span>, pp + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;?&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pp[i].second.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pp[i].second.second &lt;&lt; endl, cout.<span class="built_in">flush</span>();</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;!&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pp[i].second.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pp[i].second.second &lt;&lt; endl, cout.<span class="built_in">flush</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! 0 0&quot;</span> &lt;&lt; endl, cout.<span class="built_in">flush</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Christmas-Game"><a href="#F-Christmas-Game" class="headerlink" title="F Christmas Game"></a>F <a href="https://codeforces.com/contest/1498/problem/F">Christmas Game</a></h2><p>题目大意：给一棵树，树上有些点有礼物，每次操作是选一个点，然后将这个点上的礼物任选数量转化到这个点的第k个祖先上。假如一个点没有第k个祖先或者这个点没有礼物，就不能选这个点。对于一个给定的根，两个人轮流操作是显然会有一个人必胜的，最后要求以每一个点为根的情况下谁必胜。</p><p>解法：首先观察题目，k不超过20，对于一个链，这就是一个阶梯模k意义下的阶梯nim游戏（阶梯nim游戏就是只考虑偶数台阶上的石子异或起来的结果），再将链扩展到树上，发现对于给定根的问题，也是满足阶梯nim游戏的特性的（以根到某个点的距离在模k意义下的情况来考虑），dp[x][i]表示x的所有儿子中距离x的距离%2k==i的点上的礼物的异或和。那么接下来我们所需要做的就是换根的时候怎么做。考虑到两个点x，y的转移，假如当前x是y的儿子，要将y的结果转化到x上，也就是x所在的整颗子树所有点距离根长度都-1，与此同时除了这棵子树之外所有的点长度都+1。再回到一开始我们阶梯nim要取偶数台阶，那就给长度%2k，这样k<del>2k-1都是偶数台阶，0</del>k-1都是奇数台阶，所以到最后我们只需要通过XOR的性质以及最开始dp的定义，在转移的时候消除一下影响就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, a[<span class="number">200005</span>], b, c, dp[<span class="number">200005</span>][<span class="number">40</span>], ans[<span class="number">200005</span>], pro[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tu[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">dp[x][<span class="number">0</span>] = a[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : tu[x]) <span class="keyword">if</span>(i != y)&#123;</span><br><span class="line"><span class="built_in">dfs1</span>(i, x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k; j++)</span><br><span class="line">            dp[x][(j + <span class="number">1</span>) % (<span class="number">2</span> * k)] ^= dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x != y) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * k; i++)</span><br><span class="line">        dp[x][(i + <span class="number">1</span>) % (<span class="number">2</span> * k)] ^= pro[i];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; <span class="number">2</span> * k; i++) t ^= dp[x][i];</span><br><span class="line">ans[x] = (t != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : tu[x]) <span class="keyword">if</span>(i != y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k; j++)</span><br><span class="line">            pro[j] = dp[x][j] ^ dp[i][(j - <span class="number">1</span> + <span class="number">2</span> * k) % (<span class="number">2</span> * k)];</span><br><span class="line"><span class="built_in">dfs2</span>(i, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; b &gt;&gt; c, tu[b].<span class="built_in">push_back</span>(c), tu[c].<span class="built_in">push_back</span>(b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span> , <span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">1</span> , <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉前4道题都挺暴力的吧，可能由于个人做题比较少，E题和F题会比较令人耳目一新？F题是真的妙啊妙！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CodeCraft-21-and-Codeforces-Round-711-Div-2-cf-contest-1498&quot;&gt;&lt;a href=&quot;#CodeCraft-21-and-Codeforces-Round-711-Div-2-cf-contest-1498&quot; </summary>
      
    
    
    
    <category term="训练" scheme="http://sosupro.github.io/categories/%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="codeforces" scheme="http://sosupro.github.io/tags/codeforces/"/>
    
    <category term="cfcontest" scheme="http://sosupro.github.io/tags/cfcontest/"/>
    
  </entry>
  
  <entry>
    <title>sosusosu.com秽土转生为sosusosu.icu!</title>
    <link href="http://sosupro.github.io/2021/04/22/sosusosu-com%E7%A7%BD%E5%9C%9F%E8%BD%AC%E7%94%9F%E4%B8%BAsosusosu-icu/"/>
    <id>http://sosupro.github.io/2021/04/22/sosusosu-com%E7%A7%BD%E5%9C%9F%E8%BD%AC%E7%94%9F%E4%B8%BAsosusosu-icu/</id>
    <published>2021-04-22T15:06:51.000Z</published>
    <updated>2021-04-22T16:13:10.128Z</updated>
    
    <content type="html"><![CDATA[<p>恭喜sosusosu.com转生成为sosusosu.icu！</p><p>代表sosusosu在nt的路上越走越选，成功进入icu！</p><span id="more"></span><p>主要测试一下各项功能是否完善。</p><h1 id="目录1"><a href="#目录1" class="headerlink" title="目录1"></a>目录1</h1><h2 id="目录2"><a href="#目录2" class="headerlink" title="目录2"></a>目录2</h2><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><p>≧ ﹏ ≦</p><h3 id="目录3"><a href="#目录3" class="headerlink" title="目录3"></a>目录3</h3><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><p>(・∀・(・∀・(・∀・*)</p><h4 id="目录4"><a href="#目录4" class="headerlink" title="目录4"></a>目录4</h4><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><p>Σ(っ °Д °;)っ</p><h5 id="目录5"><a href="#目录5" class="headerlink" title="目录5"></a>目录5</h5><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><p>o(<em>￣▽￣</em>)ブ</p><h6 id="目录6"><a href="#目录6" class="headerlink" title="目录6"></a>目录6</h6><p>目录7</p><div class="alert alert-success"><p>成功啦o(<em>￣▽￣</em>)ブ</p></div><div class="alert alert-danger"><p>有危险Σ(っ °Д °;)っ</p></div><div class="alert alert-info"><p>有消息(・∀・(・∀・(・∀・*)</p></div><div class="alert alert-warning"><p>当心哦≧ ﹏ ≦</p></div><p>—分割线—</p><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>这是折叠信息</span></div>    <div class="xContent"><div class="inner">        <p>突然出现！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, a, fl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n, fl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            fl |= ((((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(a)) * ((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(a))) != a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(fl ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>     </div></div>    </div><p>—分割线—</p><div class="xControl active">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>这是可折信息</span></div>    <div class="xContent pre-open"><div class="inner">        <p>点一下就消失啦！</p>     </div></div>    </div><p>—分割线—</p><div class="panel panel-success">    <div class="panel-title">提示面板</div>    <div class="panel-body">        <p>success</p><p>danger</p><p>info</p><p>warning</p>    </div>    </div><p>图片测试！</p><img src="/2021/04/22/sosusosu-com%E7%A7%BD%E5%9C%9F%E8%BD%AC%E7%94%9F%E4%B8%BAsosusosu-icu/1.gif" class="" title="备注"><p>评论区等等再说吧，唉，今天做了一天qwq</p><p>就硬上ps，最后还不如不上hhhh</p><p>做了好多无用功，还没写题解和大作业，罪过罪过。</p><p>简而言之言而简之，由强劲的wordpress支持的sosusosu.com因为年久失修（反正也没人看）就死掉啦！</p><p>现在是由hexo支持的sosusosu.icu！希望sosusosu能够再接再厉，在ICU中发扬犯病精神，在犯病的路上一去不返！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;恭喜sosusosu.com转生成为sosusosu.icu！&lt;/p&gt;
&lt;p&gt;代表sosusosu在nt的路上越走越选，成功进入icu！&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://sosupro.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="水文" scheme="http://sosupro.github.io/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
</feed>
